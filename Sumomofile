certificate = ENV["SHINONOME_API_CERT"]
key = ENV["CLOUDFLARE_KEY"]
email = ENV["CLOUDFLARE_EMAIL"]

ui_url = "rubymusic.shinonome.astrobunny.net"
api_url = "rubymusic-api.shinonome.astrobunny.net"

if ENV["CLOUDFLARE_EMAIL"]

    config_contents = File.read("ui/main.j")

    File.write("ui/main.j", config_contents.gsub("http://192.168.1.15:5000", "https://#{api_url}"))

    `cd ui && bundle exec chino build`
    `cp ui/favicon.ico ui/build/`

    File.write("ui/main.j", config_contents)

end

cdn = make_cdn_from_dir(
    cert: certificate,
    domain: ui_url, 
    dns: cloudflare_dns(key: key, email: email), 
    dir: "ui/build", 
    low_ttl: ["*.sj"])

api = make_api api_url,
    name: "RubyMusicControlAPI",
    cert: certificate,
    dns: cloudflare_dns(key: key, email: email),
    with_statements: [
        {
            "Effect" => "Allow",
            "Action" => ["s3:DeleteObject", "s3:GetObject", "s3:PutObject"],
            "Resource" => "arn:aws:s3:::rubymusic-repository/*"
        }
    ] do

    SCRIPT <<-SCRIPT
        const crypto = require("crypto");
        const protocol = {
            https: require('https'),
            http: require('http')
        }
        const URL = require('url').URL;

        function get_library_data(type, on_complete)
        {
            Store.get("libraries/" + type,
                function(data)
                {
                    on_complete(data);
                },
                function(error)
                {
                    on_complete({});
                })
        }

        function modify_library_data(type, id, field, value, on_complete, on_error)
        {
            get_library_data(type, function(data)
            {
                if (!data[id])
                {
                    return on_error({error: "no such id"});
                }

                data[id][field] = value;
                Store.set("libraries/" + type, data,
                    function()
                    {
                        on_complete(data);
                    },
                    function(error)
                    {
                        on_error(error);
                    })
            });
        }

        function add_library_row(type, new_row, on_complete, on_error)
        {
            get_library_data(type, function(data)
            {
                crypto.randomBytes(16, function(err, buffer) {
                    var token = buffer.toString('hex');
                    new_row.id = token;
                    data[token] = new_row
                    Store.set("libraries/" + type, data,
                        function()
                        {
                            on_complete(data);
                        },
                        function(error)
                        {
                            on_error(error);
                        })
                });
            })
        }

        function convert_data(data, sort)
        {
            var keys = Object.keys(data);
            var result = {};

            var temp_array = [];
            for (var key in data)
            {
                temp_array.push(data[key]);
            }

            var idx = 0;
            var sort_info = sort.split(",");

            for(idx=0;idx<sort_info.length;idx++)
            {
                var tokens = sort_info[idx].split(":");
                var field = tokens[0];
                var asc = tokens[1] === "a" ? 1 : -1;
                temp_array.sort(function(a,b){ return asc * (a[field].localeCompare(b[field])); })
            }

            for(idx=0;idx<temp_array.length;idx++)
            {
                result[idx] = temp_array[idx];
            }

            return {data: result, length: temp_array.length}
        }

        function send_playlist_to_bot(id, playlist)
        {
            get_library_data("bots", function(data) {
                var bot = data[id];

                var bot_url = new URL(bot.location + '/playlist?token=' + bot.token);
                var proto = protocol[bot_url.protocol.replace(":", "")];

                var postData = JSON.stringify(playlist);

                var options = {
                    hostname: bot_url.hostname,
                    port: bot_url.port,
                    path: bot_url.pathname + bot_url.search,
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': Buffer.byteLength(postData, 'utf8')
                    }
                };

                var req = http.request(options, function (res) {
                    console.log('STATUS:', res.statusCode);
                    console.log('HEADERS:', JSON.stringify(res.headers));

                    res.setEncoding('utf8');

                    res.on('data', function (chunk) {
                        console.log('BODY:', chunk);
                    });

                    res.on('end', function () {
                        console.log('No more data in response.');
                    });
                });

                req.on('error', function (e) {
                    console.log('Problem with request:', e.message);
                });

                req.write(postData);
                req.end();
            });

        }

        function check_bot(id)
        {
            get_library_data("songs", function(data)
            {
                send_playlist_to_bot(id, {playlist: data})
            });

            get_library_data("bots", function(data) {
                var bot = data[id];

                var bot_url = new URL(bot.location + '/?token=' + bot.token);
                var proto = protocol[bot_url.protocol.replace(":", "")];

                proto.get(bot.location + '/?token=' + bot.token, (resp) => {

                    var bot_resp = ""

                    // A chunk of data has been recieved.
                    resp.on('data', (chunk) => {
                        bot_resp += chunk;
                    });

                    // The whole response has been received. Print out the result.
                    resp.on('end', () => {
                        var bot_response = JSON.parse(bot_resp);
                        modify_library_data("bots", id, "reachable", 1,
                            function(data){},
                            function(error){});
                        modify_library_data("bots", id, "status", bot_response.status,
                            function(data){},
                            function(error){});
                    });

                }).on("error", (err) => {
                    modify_library_data("bots", id, "reachable", 0,
                        function(data)
                        {

                        },
                        function(error)
                        {
                        });
                });
            });
        }

    SCRIPT

    def AUTH(method, path, *args)
        inner_script = args.last

        the_script = <<-SCRIPT

        Store.get("tokens/"+api_token,
        function(data)
        {
            Store.get("users/"+data.user,
            function(data)
            {
                if (data.api_token === api_token)
                {
#{inner_script}
                }
                else
                {
                    respond_with ({message: "not_found"}, 404);
                }
            },
            function(err)
            {
                respond_with ({message: "not_found"}, 404);
            })
        },
        function(err)
        {
            respond_with ({message: "not_found"}, 404);
        })

        SCRIPT

        argv = [path, :api_token] + args[0..-2] + [the_script]

        self.send(:"#{method}", *argv )
    end

    def AUTH_GET(path, *args)
        AUTH("GET", path, *args)
    end

    def AUTH_POST(path, *args)
        AUTH("POST", path, *args)
    end

    def AUTH_PUT(path, *args)
        AUTH("PUT", path, *args)
    end

    AUTH_GET "/api/session", <<-SCRIPT
        respond_with ({message: "ok", api_token: data.api_token}, 200);
    SCRIPT

    AUTH_GET "/api/bots/library", :item, :sort, <<-SCRIPT
        get_library_data("bots", function(data)
        {
            var result = convert_data(data, sort)
            respond_with ({message: "ok", data: result.data, data_length: result.length}, 200);
        });
    SCRIPT

    AUTH_POST "/api/bots/library", <<-SCRIPT

        add_library_row("bots", 
            {
                name: "<name>",
                token: "<token>",
                location: "<location>",
                playlist: "",
                playing: 0,
                reachable: 0,
                status: ""
            },
            function(data)
            {
                respond_with ({message: "created"}, 201);
            },
            function(error)
            {
                console.log(error)
                respond_with ({message: "internal_error"}, 500);  
            });
    SCRIPT

    AUTH_POST "/api/bots/library/modify", :id, :field, :value, <<-SCRIPT
        modify_library_data("bots", id, field, value,
            function(data)
            {
                check_bot(id);
                respond_with ({message: "ok"}, 200);
            },
            function(error)
            {
                console.log(error)
                respond_with ({message: "internal_error"}, 500);  
            });
    SCRIPT

    AUTH_GET "/api/songs/library", :item, :sort, <<-SCRIPT
        get_library_data("songs", function(data)
        {
            var result = convert_data(data, sort)
            respond_with ({message: "ok", data: result.data, data_length: result.length}, 200);
        });
    SCRIPT

    AUTH_POST "/api/songs/library", <<-SCRIPT
        add_library_row("songs", 
            {
                name: "<name>",
                artist_name: "<artist_name>",
                url: "<url>",
                tags: []
            },
            function(data)
            {
                respond_with ({message: "created"}, 201);
            },
            function(error)
            {
                console.log(error)
                respond_with ({message: "internal_error"}, 500);  
            });
    SCRIPT

    AUTH_POST "/api/songs/library/modify", :id, :field, :value, <<-SCRIPT
        modify_library_data("songs", id, field, value,
            function(data)
            {
                respond_with ({message: "ok"}, 200);
            },
            function(error)
            {
                console.log(error)
                respond_with ({message: "internal_error"}, 500);  
            });
    SCRIPT

    POST "/api/session", :username, :password, <<-SCRIPT

        Store.get("users/"+username,
        function(data)
        {
            const hash = crypto.createHash('sha256', "")
                               .update(password)
                               .update(data.salt)
                               .digest('hex');

            if (hash === data.password_hash)
            {
                crypto.randomBytes(16, (err, buf) => {
                    if (err) throw err;
                    data.api_token = buf.toString('hex')

                    Store.set("users/"+username, data,
                    function()
                    {
                        Store.set("tokens/"+data.api_token, {user: data.username},
                        function()
                        {
                            respond_with ({message: "ok", api_token: data.api_token}, 200);
                        },
                        function(err)
                        {
                            console.log("Error saving token")
                            respond_with ({message: "not_found"}, 404);
                        });
                    },
                    function(err)
                    {
                        console.log("Error saving user")
                        respond_with ({message: "not_found"}, 404);
                    });
                });
            }
            else
            {
                respond_with ({message: "not_found"}, 404);
            }

        },
        function(err)
        {
            respond_with ({message: "not_found"}, 404);
        })

    SCRIPT

    

end

output "DistroHost", ui_url
output "APIURL", api
